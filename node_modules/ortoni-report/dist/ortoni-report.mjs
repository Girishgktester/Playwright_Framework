import {
  __require,
  startReportServer
} from "./chunk-ZSIRUQUA.mjs";

// src/helpers/fileManager.ts
import fs from "fs";
import path from "path";
var FileManager = class {
  constructor(folderPath) {
    this.folderPath = folderPath;
  }
  ensureReportDirectory() {
    const ortoniDataFolder = path.join(this.folderPath, "ortoni-data");
    if (!fs.existsSync(this.folderPath)) {
      fs.mkdirSync(this.folderPath, { recursive: true });
    } else {
      if (fs.existsSync(ortoniDataFolder)) {
        fs.rmSync(ortoniDataFolder, { recursive: true, force: true });
      }
    }
  }
  writeReportFile(filename, content) {
    const outputPath = path.join(process.cwd(), this.folderPath, filename);
    fs.writeFileSync(outputPath, content);
    return outputPath;
  }
  readCssContent() {
    return fs.readFileSync(path.resolve(__dirname, "style", "main.css"), "utf-8");
  }
  copyTraceViewerAssets() {
    const traceViewerFolder = path.join(__require.resolve("playwright-core"), "..", "lib", "vite", "traceViewer");
    const traceViewerTargetFolder = path.join(this.folderPath, "trace");
    const traceViewerAssetsTargetFolder = path.join(traceViewerTargetFolder, "assets");
    fs.mkdirSync(traceViewerAssetsTargetFolder, { recursive: true });
    for (const file of fs.readdirSync(traceViewerFolder)) {
      if (file.endsWith(".map") || file.includes("watch") || file.includes("assets")) continue;
      fs.copyFileSync(path.join(traceViewerFolder, file), path.join(traceViewerTargetFolder, file));
    }
    const assetsFolder = path.join(traceViewerFolder, "assets");
    for (const file of fs.readdirSync(assetsFolder)) {
      if (file.endsWith(".map") || file.includes("xtermModule")) continue;
      fs.copyFileSync(path.join(assetsFolder, file), path.join(traceViewerAssetsTargetFolder, file));
    }
  }
};

// src/helpers/HTMLGenerator.ts
import path3 from "path";

// src/utils/groupProjects.ts
function groupResults(config, results) {
  if (config.showProject) {
    const groupedResults = results.reduce((acc, result, index) => {
      const testId = `${result.filePath}:${result.projectName}:${result.title}`;
      const { filePath, suite, projectName } = result;
      acc[filePath] = acc[filePath] || {};
      acc[filePath][suite] = acc[filePath][suite] || {};
      acc[filePath][suite][projectName] = acc[filePath][suite][projectName] || [];
      acc[filePath][suite][projectName].push({ ...result, index, testId });
      return acc;
    }, {});
    return groupedResults;
  } else {
    const groupedResults = results.reduce((acc, result, index) => {
      const testId = `${result.filePath}:${result.projectName}:${result.title}`;
      const { filePath, suite } = result;
      acc[filePath] = acc[filePath] || {};
      acc[filePath][suite] = acc[filePath][suite] || [];
      acc[filePath][suite].push({ ...result, index, testId });
      return acc;
    }, {});
    return groupedResults;
  }
}

// src/utils/utils.ts
import path2 from "path";
function msToTime(duration) {
  const milliseconds = Math.floor(duration % 1e3);
  const seconds = Math.floor(duration / 1e3 % 60);
  const minutes = Math.floor(duration / (1e3 * 60) % 60);
  const hours = Math.floor(duration / (1e3 * 60 * 60) % 24);
  let result = "";
  if (hours > 0) {
    result += `${hours}h:`;
  }
  if (minutes > 0 || hours > 0) {
    result += `${minutes < 10 ? "0" + minutes : minutes}m:`;
  }
  if (seconds > 0 || minutes > 0 || hours > 0) {
    result += `${seconds < 10 ? "0" + seconds : seconds}s`;
  }
  if (milliseconds > 0 && !(seconds > 0 || minutes > 0 || hours > 0)) {
    result += `${milliseconds}ms`;
  } else if (milliseconds > 0) {
    result += `:${milliseconds < 100 ? "0" + milliseconds : milliseconds}ms`;
  }
  return result;
}
function normalizeFilePath(filePath) {
  const normalizedPath = path2.normalize(filePath);
  return path2.basename(normalizedPath);
}
function formatDate(date) {
  const day = String(date.getDate()).padStart(2, "0");
  const month = date.toLocaleString("default", { month: "short" });
  const year = date.getFullYear();
  const time = date.toLocaleTimeString();
  return `${day}-${month}-${year} ${time}`;
}
function safeStringify(obj, indent = 2) {
  const cache = /* @__PURE__ */ new Set();
  const json = JSON.stringify(obj, (key, value) => {
    if (typeof value === "object" && value !== null) {
      if (cache.has(value)) {
        return;
      }
      cache.add(value);
    }
    return value;
  }, indent);
  cache.clear();
  return json;
}
function ensureHtmlExtension(filename) {
  const ext = path2.extname(filename);
  if (ext && ext.toLowerCase() === ".html") {
    return filename;
  }
  return `${filename}.html`;
}
function escapeHtml(unsafe) {
  if (typeof unsafe !== "string") {
    return String(unsafe);
  }
  return unsafe.replace(/[&<"']/g, function(match) {
    const escapeMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#039;"
    };
    return escapeMap[match] || match;
  });
}
function formatDateUTC(date) {
  return date.toISOString();
}
function formatDateLocal(isoString) {
  const date = new Date(isoString);
  const options = {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    // second: '2-digit',
    hour12: true,
    timeZoneName: "short"
  };
  return new Intl.DateTimeFormat(void 0, options).format(date);
}

// src/helpers/HTMLGenerator.ts
import fs2 from "fs";
import Handlebars from "handlebars";
var HTMLGenerator = class {
  constructor(ortoniConfig, dbManager) {
    this.ortoniConfig = ortoniConfig;
    this.registerHandlebarsHelpers();
    this.registerPartials();
    this.dbManager = dbManager;
  }
  async generateHTML(filteredResults, totalDuration, cssContent, results, projectSet) {
    const data = await this.prepareReportData(
      filteredResults,
      totalDuration,
      results,
      projectSet
    );
    const templateSource = fs2.readFileSync(
      path3.resolve(__dirname, "views", "main.hbs"),
      "utf-8"
    );
    const template = Handlebars.compile(templateSource);
    return template({ ...data, inlineCss: cssContent });
  }
  async prepareReportData(filteredResults, totalDuration, results, projectSet) {
    const totalTests = filteredResults.length;
    const passedTests = results.filter((r) => r.status === "passed").length;
    const flakyTests = results.filter((r) => r.status === "flaky").length;
    const failed = filteredResults.filter(
      (r) => r.status === "failed" || r.status === "timedOut"
    ).length;
    const successRate = ((passedTests + flakyTests) / totalTests * 100).toFixed(2);
    const allTags = /* @__PURE__ */ new Set();
    results.forEach(
      (result) => result.testTags.forEach((tag) => allTags.add(tag))
    );
    const projectResults = this.calculateProjectResults(
      filteredResults,
      results,
      projectSet
    );
    const utcRunDate = formatDateUTC(/* @__PURE__ */ new Date());
    const localRunDate = formatDateLocal(utcRunDate);
    const testHistories = await Promise.all(
      results.map(async (result) => {
        const testId = `${result.filePath}:${result.projectName}:${result.title}`;
        const history = await this.dbManager.getTestHistory(testId);
        return {
          testId,
          history
        };
      })
    );
    return {
      utcRunDate,
      localRunDate,
      testHistories,
      logo: this.ortoniConfig.logo || void 0,
      totalDuration,
      results,
      retryCount: results.filter((r) => r.isRetry).length,
      passCount: passedTests,
      failCount: failed,
      skipCount: results.filter((r) => r.status === "skipped").length,
      flakyCount: flakyTests,
      totalCount: filteredResults.length,
      groupedResults: groupResults(this.ortoniConfig, results),
      projectName: this.ortoniConfig.projectName,
      authorName: this.ortoniConfig.authorName,
      meta: this.ortoniConfig.meta,
      testType: this.ortoniConfig.testType,
      preferredTheme: this.ortoniConfig.preferredTheme,
      successRate,
      lastRunDate: formatDate(/* @__PURE__ */ new Date()),
      projects: projectSet,
      allTags: Array.from(allTags),
      showProject: this.ortoniConfig.showProject || false,
      title: this.ortoniConfig.title || "Ortoni Playwright Test Report",
      ...this.extractProjectStats(projectResults)
    };
  }
  calculateProjectResults(filteredResults, results, projectSet) {
    return Array.from(projectSet).map((projectName) => {
      const projectTests = filteredResults.filter(
        (r) => r.projectName === projectName
      );
      const allProjectTests = results.filter(
        (r) => r.projectName === projectName
      );
      return {
        projectName,
        passedTests: projectTests.filter((r) => r.status === "passed").length,
        failedTests: projectTests.filter(
          (r) => r.status === "failed" || r.status === "timedOut"
        ).length,
        skippedTests: allProjectTests.filter((r) => r.status === "skipped").length,
        retryTests: allProjectTests.filter((r) => r.isRetry).length,
        flakyTests: allProjectTests.filter((r) => r.status === "flaky").length,
        totalTests: projectTests.length
      };
    });
  }
  extractProjectStats(projectResults) {
    return {
      projectNames: projectResults.map((result) => result.projectName),
      totalTests: projectResults.map((result) => result.totalTests),
      passedTests: projectResults.map((result) => result.passedTests),
      failedTests: projectResults.map((result) => result.failedTests),
      skippedTests: projectResults.map((result) => result.skippedTests),
      retryTests: projectResults.map((result) => result.retryTests),
      flakyTests: projectResults.map((result) => result.flakyTests)
    };
  }
  registerHandlebarsHelpers() {
    Handlebars.registerHelper("joinWithSpace", (array) => array.join(" "));
    Handlebars.registerHelper("json", (context) => safeStringify(context));
    Handlebars.registerHelper(
      "eq",
      (actualStatus, expectedStatus) => actualStatus === expectedStatus
    );
    Handlebars.registerHelper(
      "includes",
      (actualStatus, expectedStatus) => actualStatus.includes(expectedStatus)
    );
    Handlebars.registerHelper("gr", (count) => count > 0);
    Handlebars.registerHelper("or", function(a, b) {
      return a || b;
    });
    Handlebars.registerHelper("concat", function(...args) {
      args.pop();
      return args.join("");
    });
  }
  registerPartials() {
    [
      "head",
      "sidebar",
      "testPanel",
      "summaryCard",
      "userInfo",
      "project",
      "testStatus",
      "testIcons"
    ].forEach((partialName) => {
      Handlebars.registerPartial(
        partialName,
        fs2.readFileSync(
          path3.resolve(__dirname, "views", `${partialName}.hbs`),
          "utf-8"
        )
      );
    });
  }
};

// src/helpers/resultProcessor .ts
import AnsiToHtml from "ansi-to-html";
import path5 from "path";

// src/utils/attachFiles.ts
import path4 from "path";
import fs3 from "fs";
function attachFiles(subFolder, result, testResult, config) {
  const folderPath = config.folderPath || "ortoni-report";
  const attachmentsFolder = path4.join(folderPath, "ortoni-data", "attachments", subFolder);
  if (!fs3.existsSync(attachmentsFolder)) {
    fs3.mkdirSync(attachmentsFolder, { recursive: true });
  }
  if (!result.attachments) return;
  const { base64Image } = config;
  testResult.screenshots = [];
  result.attachments.forEach((attachment) => {
    const { contentType, name, path: attachmentPath, body } = attachment;
    if (!attachmentPath && !body) return;
    const fileName = attachmentPath ? path4.basename(attachmentPath) : `${name}.${getFileExtension(contentType)}`;
    const relativePath = path4.join("ortoni-data", "attachments", subFolder, fileName);
    const fullPath = path4.join(attachmentsFolder, fileName);
    if (contentType === "image/png") {
      handleImage(attachmentPath, body, base64Image, fullPath, relativePath, testResult);
    } else if (name === "video") {
      handleAttachment(attachmentPath, fullPath, relativePath, "videoPath", testResult);
    } else if (name === "trace") {
      handleAttachment(attachmentPath, fullPath, relativePath, "tracePath", testResult);
    }
  });
}
function handleImage(attachmentPath, body, base64Image, fullPath, relativePath, testResult) {
  let screenshotPath = "";
  if (attachmentPath) {
    try {
      const screenshotContent = fs3.readFileSync(attachmentPath, base64Image ? "base64" : void 0);
      screenshotPath = base64Image ? `data:image/png;base64,${screenshotContent}` : relativePath;
      if (!base64Image) {
        fs3.copyFileSync(attachmentPath, fullPath);
      }
    } catch (error) {
      console.error(`OrtoniReport: Failed to read screenshot file: ${attachmentPath}`, error);
    }
  } else if (body) {
    screenshotPath = `data:image/png;base64,${body.toString("base64")}`;
  }
  if (screenshotPath) {
    testResult.screenshots?.push(screenshotPath);
  }
}
function handleAttachment(attachmentPath, fullPath, relativePath, resultKey, testResult) {
  if (attachmentPath) {
    fs3.copyFileSync(attachmentPath, fullPath);
    testResult[resultKey] = relativePath;
  }
}
function getFileExtension(contentType) {
  const extensions = {
    "image/png": "png",
    "video/webm": "webm",
    "application/zip": "zip"
  };
  return extensions[contentType] || "unknown";
}

// src/helpers/resultProcessor .ts
var TestResultProcessor = class {
  constructor(projectRoot) {
    this.ansiToHtml = new AnsiToHtml({ fg: "var(--snippet-color)" });
    this.projectRoot = projectRoot;
  }
  processTestResult(test, result, projectSet, ortoniConfig) {
    const status = test.outcome() === "flaky" ? "flaky" : result.status;
    const projectName = test.titlePath()[1];
    projectSet.add(projectName);
    const location = test.location;
    const filePath = normalizeFilePath(test.titlePath()[2]);
    const tagPattern = /@[\w]+/g;
    const title = test.title.replace(tagPattern, "").trim();
    const suite = test.titlePath()[3].replace(tagPattern, "").trim();
    const testResult = {
      port: ortoniConfig.port || 2004,
      annotations: test.annotations,
      testTags: test.tags,
      location: `${filePath}:${location.line}:${location.column}`,
      retry: result.retry > 0 ? "retry" : "",
      isRetry: result.retry,
      projectName,
      suite,
      title,
      status,
      flaky: test.outcome(),
      duration: msToTime(result.duration),
      errors: result.errors.map((e) => this.ansiToHtml.toHtml(escapeHtml(e.stack || e.toString()))),
      steps: this.processSteps(result.steps),
      logs: this.ansiToHtml.toHtml(escapeHtml(result.stdout.concat(result.stderr).map((log) => log).join("\n"))),
      filePath,
      filters: projectSet,
      base64Image: ortoniConfig.base64Image
    };
    attachFiles(test.id, result, testResult, ortoniConfig);
    return testResult;
  }
  processSteps(steps) {
    return steps.map((step) => {
      const stepLocation = step.location ? `${path5.relative(this.projectRoot, step.location.file)}:${step.location.line}:${step.location.column}` : "";
      return {
        snippet: this.ansiToHtml.toHtml(escapeHtml(step.error?.snippet || "")),
        title: step.title,
        location: step.error ? stepLocation : ""
      };
    });
  }
};

// src/helpers/serverManager.ts
var ServerManager = class {
  constructor(ortoniConfig) {
    this.ortoniConfig = ortoniConfig;
  }
  startServer(folderPath, outputFilename, overAllStatus) {
    const openOption = this.ortoniConfig.open || "never";
    const hasFailures = overAllStatus === "failed";
    if (openOption === "always" || openOption === "on-failure" && hasFailures) {
      startReportServer(
        folderPath,
        outputFilename,
        this.ortoniConfig.port,
        openOption
      );
    }
  }
};

// src/helpers/databaseManager.ts
import { open } from "sqlite";
import sqlite3 from "sqlite3";
var DatabaseManager = class {
  constructor() {
    this.db = null;
  }
  async initialize(dbPath) {
    try {
      this.db = await open({
        filename: dbPath,
        driver: sqlite3.Database
      });
      await this.createTables();
      await this.createIndexes();
    } catch (error) {
      console.error("OrtoniReport: Error initializing database:", error);
    }
  }
  async createTables() {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return;
    }
    try {
      await this.db.exec(`
        CREATE TABLE IF NOT EXISTS test_runs (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          run_date TEXT
        );

        CREATE TABLE IF NOT EXISTS test_results (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          run_id INTEGER,
          test_id TEXT,
          status TEXT,
          duration TEXT,
          error_message TEXT,
          FOREIGN KEY (run_id) REFERENCES test_runs (id)
        );
      `);
    } catch (error) {
      console.error("OrtoniReport: Error creating tables:", error);
    }
  }
  async createIndexes() {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return;
    }
    try {
      await this.db.exec(`
        CREATE INDEX IF NOT EXISTS idx_test_id ON test_results (test_id);
        CREATE INDEX IF NOT EXISTS idx_run_id ON test_results (run_id);
      `);
    } catch (error) {
      console.error("OrtoniReport: Error creating indexes:", error);
    }
  }
  async saveTestRun() {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return null;
    }
    try {
      const runDate = formatDateUTC(/* @__PURE__ */ new Date());
      const { lastID } = await this.db.run(
        `
        INSERT INTO test_runs (run_date)
        VALUES (?)
      `,
        [runDate]
      );
      return lastID;
    } catch (error) {
      console.error("OrtoniReport: Error saving test run:", error);
      return null;
    }
  }
  async saveTestResults(runId, results) {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return;
    }
    try {
      await this.db.exec("BEGIN TRANSACTION;");
      const stmt = await this.db.prepare(`
        INSERT INTO test_results (run_id, test_id, status, duration, error_message)
        VALUES (?, ?, ?, ?, ?)
      `);
      for (const result of results) {
        await stmt.run([
          runId,
          `${result.filePath}:${result.projectName}:${result.title}`,
          result.status,
          result.duration,
          result.errors.join("\n")
        ]);
      }
      await stmt.finalize();
      await this.db.exec("COMMIT;");
    } catch (error) {
      await this.db.exec("ROLLBACK;");
      console.error("OrtoniReport: Error saving test results:", error);
    }
  }
  async getTestHistory(testId, limit = 10) {
    if (!this.db) {
      console.error("OrtoniReport: Database not initialized");
      return [];
    }
    try {
      const results = await this.db.all(
        `
        SELECT tr.status, tr.duration, tr.error_message, trun.run_date
        FROM test_results tr
        JOIN test_runs trun ON tr.run_id = trun.id
        WHERE tr.test_id = ?
        ORDER BY trun.run_date DESC
        LIMIT ?
      `,
        [testId, limit]
      );
      return results.map((result) => ({
        ...result,
        run_date: formatDateLocal(result.run_date)
      }));
    } catch (error) {
      console.error("OrtoniReport: Error getting test history:", error);
      return [];
    }
  }
  async close() {
    if (this.db) {
      try {
        await this.db.close();
      } catch (error) {
        console.error("OrtoniReport: Error closing database:", error);
      } finally {
        this.db = null;
      }
    }
  }
};

// src/ortoni-report.ts
import path6 from "path";
var OrtoniReport = class {
  constructor(ortoniConfig = {}) {
    this.ortoniConfig = ortoniConfig;
    this.results = [];
    this.projectSet = /* @__PURE__ */ new Set();
    this.shouldGenerateReport = true;
    this.showConsoleLogs = true;
    this.reportsCount = 0;
    this.folderPath = ortoniConfig.folderPath || "ortoni-report";
    this.outputFilename = ensureHtmlExtension(ortoniConfig.filename || "ortoni-report.html");
    this.dbManager = new DatabaseManager();
    this.htmlGenerator = new HTMLGenerator(ortoniConfig, this.dbManager);
    this.fileManager = new FileManager(this.folderPath);
    this.serverManager = new ServerManager(ortoniConfig);
    this.testResultProcessor = new TestResultProcessor("");
    this.showConsoleLogs = ortoniConfig.stdIO !== false;
  }
  async onBegin(config, _suite) {
    this.reportsCount = config.reporter.length;
    this.results = [];
    this.testResultProcessor = new TestResultProcessor(config.rootDir);
    this.fileManager.ensureReportDirectory();
    await this.dbManager.initialize(path6.join(this.folderPath, "ortoni-data-history.sqlite"));
  }
  onStdOut(chunk, _test, _result) {
    if (this.reportsCount == 1 && this.showConsoleLogs) {
      console.log(chunk.toString().trim());
    }
  }
  onTestEnd(test, result) {
    try {
      const testResult = this.testResultProcessor.processTestResult(test, result, this.projectSet, this.ortoniConfig);
      this.results.push(testResult);
    } catch (error) {
      console.error("OrtoniReport: Error processing test end:", error);
    }
  }
  printsToStdio() {
    return true;
  }
  onError(error) {
    if (error.location === void 0) {
      this.shouldGenerateReport = false;
    }
  }
  async onEnd(result) {
    try {
      this.overAllStatus = result.status;
      if (this.shouldGenerateReport) {
        const filteredResults = this.results.filter((r) => r.status !== "skipped" && !r.isRetry);
        const totalDuration = msToTime(result.duration);
        const cssContent = this.fileManager.readCssContent();
        const runId = await this.dbManager.saveTestRun();
        if (runId !== null) {
          await this.dbManager.saveTestResults(runId, this.results);
          const html = await this.htmlGenerator.generateHTML(filteredResults, totalDuration, cssContent, this.results, this.projectSet);
          this.outputPath = this.fileManager.writeReportFile(this.outputFilename, html);
        } else {
          console.error("OrtoniReport: Error saving test run to database");
        }
      } else {
        console.error("OrtoniReport: Report generation skipped due to error in Playwright worker!");
      }
    } catch (error) {
      this.shouldGenerateReport = false;
      console.error("OrtoniReport: Error generating report:", error);
    }
  }
  async onExit() {
    try {
      await this.dbManager.close();
      if (this.shouldGenerateReport) {
        this.fileManager.copyTraceViewerAssets();
        console.info(`Ortoni HTML report generated at ${this.outputPath}`);
        this.serverManager.startServer(this.folderPath, this.outputFilename, this.overAllStatus);
        await new Promise((_resolve) => {
        });
      }
    } catch (error) {
      console.error("OrtoniReport: Error in onExit:", error);
    }
  }
};
export {
  OrtoniReport,
  OrtoniReport as default
};
